"""
Django settings for simple_django_app project.

Generated by 'django-admin startproject' using Django 3.2.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.2/ref/settings/
"""

from pathlib import Path

import environ

BASE_DIR = Path(__file__).resolve().parent.parent

env = environ.Env(
    DEBUG=(bool, False),
    CI=(bool, False),
    ALLOWED_HOSTS=(list, []),
)
env_file = BASE_DIR / ".env"
if env_file.exists():
    # The .env file is probably only present in DEBUG environments. This
    # check prevents `read_env` from emitting a warning when it's not
    # found.
    environ.Env.read_env(env_file=str(BASE_DIR / ".env"))

# Keep the SECRET_KEY used in production secret and never run in DEBUG
# mode in production. For more information regarding deployment, please
# see https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/
SECRET_KEY = env("SECRET_KEY")
DEBUG = env("DEBUG")

if DEBUG or env("CI"):
    # Allow all hosts in DEBUG-mode or in CI.
    ALLOWED_HOSTS = ["*"]
else:
    ALLOWED_HOSTS = env("ALLOWED_HOSTS")


# The order of these applications is significant. Django will search
# from top to bottom for apps that implement the current feature it's
# looking for. For example, if two apps define a manage.py-command with
# the same name, the application that is specified first will provide
# the implementation used.
#
# This is why Django apps created for this project are typically listed
# first: We want to use the templates and features defined there instead
# of a feature in one of the default Django apps.
INSTALLED_APPS = [
    "whitenoise.runserver_nostatic",
    # Apps defined in this Django project
    "simple_django_app.core",
    "simple_django_app.blog",
    # Default Django apps, most are optional
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]

# The same as holds for INSTALLED_APPS holds for MIDDLEWARE: Django
# will call on the MIDDLEWARE in the defined order. This is why the
# whitenoise middleware is listed so high: It will recognize a request
# for static content and return early, without Django having to go
# through all other middlewares.
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

# Django's request routing is based solely on its URL router. It does
# not call itself an MVC (Model-View-Controller)) but rather an MTV
# (Model-Template-View) framework. The URL router is what determines
# the flow of a request through the application, as it routes the
# requests to views.
#
# To add more routing, you "include" the URL routers of apps into the
# main project URL router.
ROOT_URLCONF = "simple_django_app.urls"

# By default, Django uses DjangoTemplates as the back-end for rendering
# HTML templates. This uses the Django-specific Django Template Language
# that comes with some handy Django-tailored template tags. It's a bit
# similar to Jinja2, but not quite equal. It's fairly trivial to switch
# to a Jinja2-backed templating system, though.
#
# Django supports two "types" of template directories: directories
# within each app folder and central template directories specified in
# the DIRS list in the settings below. Those directories are searched
# in order, returning the first template matching the path specified.
#
# To make sure Django finds the "right" template, it's recommended to
# place templates in a subdirectory named after the app *even* if you
# are using a template directory within an APP_DIR.
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "simple_django_app" / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "simple_django_app.wsgi.application"

# A mapping of a database label to a database configuration. Typically,
# a database config is specified using a database URL parsed by the
# Django-environ package. Django support multiple databases out of the
# box, although it almost always requires additional configuration,
# since using multiple databases is not a one-solution-fits-all
# situation.
DATABASES = {
    "default": env.db(),
}


# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

# The default language for internationalization options. Django's
# admin panel already has some internationalization options. Setting
# this to `nl-NL` will automatically translate the admin panel.
#
# Whether or not this affects the front-end depends on whether or not
# we implement internationalization/use internationalization tools.
LANGUAGE_CODE = "nl-NL"

# The default TIME_ZONE for rendering datetimes in templates.
#
# Note for running Django on Windows: As Windows sets the system clock
# to local time, this field has to be set to the local time of the
# Windows machine it's running on to allow Django to interpret the
# system clock correctly.
TIME_ZONE = "Europe/Amsterdam"

# This will enable Django's time zone support. In essence, this means
# that Django will store date/time data in UTC in the database, and
# that it will use timezone-aware datetime instances internally, with
# automatic translation to the end user's timezone in templates and
# forms.
USE_TZ = True

# Internationalization and localization support. Unsure if we're going
# to use L10N, but I18N (i.e., "internationalization") is a fairly easy
# way of providing multi-language support.
USE_I18N = True
USE_L10N = True

# Configuration for static files.
#
# When we add static files to our project, we will add them to one
# of the directories specified in the STATICFILES_DIRS, but apps we
# use may also have their own static files directories.
#
# We will mostly be using whitenoise to serve static files directly
# from Django to make it self-contained application. In order for
# whitenoise to work, we need to collect the static files into a
# single directory, the STATIC_ROOT. We can do that by running the
# django-admin/manage.py command `collectstatic`, which will walk all
# STATICFILES_DIRS to "collect" files into the STATIC_ROOT.
#
# Static files will get a specific URL:
# {PUBLIC_DOMAIN}/{STATIC_URL}/path/to/static/file
#
# See https://docs.djangoproject.com/en/3.2/howto/static-files/
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "simple_django_app" / "static"]
STATIC_ROOT = env.str("STATIC_ROOT", default=BASE_DIR / "staticfiles")

# This will enable whitenoise's compressed forever-caching, see
# http://whitenoise.evans.io/en/stable/django.html#add-compression-and-caching-support
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
        },
    },
    "loggers": {
        "simple_django_app": {
            "handlers": ["console"],
            "level": "DEBUG" if DEBUG else "INFO",
        },
    },
    "root": {
        "level": "WARNING",
    },
}
